#! /usr/bin/env python

import argparse
import glob
import os
import shutil
import signal
import subprocess
import sys

def getDistMakerVersion():
	# Retrieve the install path
	installPath = getInstallRoot()
	installPath = os.path.dirname(installPath)

	# Check for distMaker.jar library prerequisite
	testPath = os.path.join(installPath, 'lib', 'distMaker.jar')
	if os.path.exists(testPath) == False:
		errPrintln('Aborting DistMaker release build. The file  ' + testPath + ' does not exist.', indent=1)
		errPrintln('Please run the buildDistMakerBin.jardesc from your workspace.', indent=1)
		exit(-1)

	try:
		exeCmd = ['java', '-cp', 'lib/distMaker.jar', 'distMaker.DistApp', '--version']
		output = subprocess.check_output(exeCmd).decode('utf-8')
		version = output.split()[1]
		return version
	except:
		errPrintln('Please run the buildDistMakerBin.jardesc from your workspace.', indent=1)
		exit(-1)


def errPrintln(message="", indent=0):
	"""Print the specified string with a trailing newline to stderr."""
	while indent > 0:
		indent -= 1
		message = '   ' + message
	sys.stderr.write(message + '\n')


def buildRelease(version, doNotClean=False):
	# Retrieve the install path
	installPath = getInstallRoot()
	installPath = os.path.dirname(installPath)

	# Check for static jre prerequisites
	isPass = os.path.exists(os.path.join(installPath, 'jre'))
	if isPass == False:
		errPrintln('Aborting DistMaker release build. The jre path is not properly configured.', indent=1)
		errPrintln('Please setup the jre path properly. A quick fix is to copy the jre tree from a previous release of DistMaker.', indent=1)
		exit(-1)

	# Determine the workPath
	workPath = os.path.join(installPath, 'release', 'DistMaker-' + version)
	destFileGZ = os.path.join(installPath, 'release', 'DistMaker-' + version + '.tar.gz')

	# Bail if the work folder for which we compose the release already exists
	if os.path.exists(workPath) == True:
		errPrintln('Aborting DistMaker release build. Release folder already exists: ' + workPath, indent=1)
		exit(-1)

	# Bail if the release already exists
	if os.path.exists(destFileGZ) == True:
		errPrintln('Aborting DistMaker release build. Release already exists. File: ' + destFileGZ, indent=1)
		exit(-1)

	# Laydown the structure, and let the user know of the version we are building
	print('Building DistMaker release ' + version + '...')
	os.mkdir(workPath)

	# Copy the libraries
	dstPath = os.path.join(workPath, 'lib')
	os.mkdir(dstPath)
	for aLib in ['glum.jar', 'guava-18.0.jar', 'distMaker.jar']:
		srcPath = os.path.join(installPath, 'lib', aLib)
		shutil.copy2(srcPath, dstPath)

	# Copy the scripts
	dstPath = os.path.join(workPath, 'script')
	os.mkdir(dstPath)
	for aScript in ['appleUtils.py', 'linuxUtils.py', 'windowsUtils.py', 'buildDist.py', 'deployAppDist.py', 'deployJreDist.py', 'jreUtils.py', 'logUtils.py', 'miscUtils.py']:
		srcPath = os.path.join(installPath, 'script', aScript)
		shutil.copy2(srcPath, dstPath)

	# Copy the (tar.gz) JREs
	globPath = os.path.join(installPath, 'jre/jre-*.tar.gz')
	dstPath = os.path.join(workPath, 'jre')
	os.mkdir(dstPath)
	for aFile in glob.glob(globPath):
		shutil.copy2(aFile, dstPath)

	# Setup the template tree
	dstPath = os.path.join(workPath, 'template')
	os.makedirs(dstPath + '/apple')
	os.makedirs(dstPath + '/background')
	os.makedirs(dstPath + '/launch4j')
	for aFile in ['appLauncher.jar', '.DS_Store.template', 'apple/JavaAppLauncher', 'apple/JavaApplicationStub', 'background/background.png', 'launch4j/launch4j-3.8-linux.tgz', 'launch4j/launch4j-3.8-macosx-x86-10.8.tgz']:
		srcPath = os.path.join(installPath, 'template', aFile)
		shutil.copy2(srcPath, dstPath + '/' + aFile)

	# Form the archive
	exeCmd = ['tar', '-czf', destFileGZ, '-C', os.path.dirname(workPath), os.path.basename(workPath)]
	retCode = subprocess.call(exeCmd)
	if retCode != 0:
		print('Failed to build tar.gz file: ' + destFileGZ)
		exit(-1)

	# Remove the workPath
	if doNotClean == False:
		shutil.rmtree(workPath)

	print('DistMaker release ' + version + ' built.')


def getInstallRoot():
	"""Returns the root path where the running script is installed."""
	argv = sys.argv;
	installRoot = os.path.dirname(argv[0])
# 	print('appInstallRoot: ' + appInstallRoot)
	return installRoot


def handleSignal(signal, frame):
		"""Signal handler, typically used to capture ctrl-c."""
		print('User aborted processing!')
		sys.exit(0)


if __name__ == "__main__":
	# Logic to capture Ctrl-C and bail
	signal.signal(signal.SIGINT, handleSignal)

	tmpDescr = 'Utility to build a DistMaker release\n'
	parser = argparse.ArgumentParser(prefix_chars='-', description=tmpDescr, add_help=False, fromfile_prefix_chars='@')
	parser.add_argument('-help', '-h', help='Show this help message and exit.', action='help')
	parser.add_argument('-doNotClean', default=False, action='store_true', help='Do NOT remove temporary work folder created while generating release.')
	parser.add_argument('-doFullBuild', default=False, action='store_true', help='Force a full build of the main jar file. (Unsupported action)')

	# Intercept any request for a  help message and bail
	argv = sys.argv;
	if '-h' in argv or '-help' in argv:
		parser.print_help()
		exit()

	# Parse the args
	parser.formatter_class.max_help_position = 50
	args = parser.parse_args()

	# Get the version of DistMaker we are building
	version = getDistMakerVersion()
	print('DistMaker version: ' + version)

	# TODO: Finish this functionality
	if args.doFullBuild == True:
		print("Unsupported action: [-doFullBuild]. Skipping...")

	buildRelease(version, args.doNotClean)
